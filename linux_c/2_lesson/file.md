# 进程
	承担分配系统资源的基本实体
# 线程
	在一个程序里的一个执行路线就叫做线程(tread)。线程是"一个进程内部的控制序列"
	是调度的基本单位，线程是进程里面的执行流(线程在进程的地址空间内运行)

进程：线程 = 1：n

Linux中没有真正意义上的线程！线程是用进程模拟的(没有专门为线程设置底层数据结构) -- 依旧使用task_struct表示 -- 轻量级进程
Windows有一个TCB的线程数据结构
透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每一个执行流，就形成了线程执行流

# 线程的优点  

	1. 创建一个线程的代价比创建一个进程小的多
	2. 与进程之间的切换相比，线程切换操作系统需要做的工作少的多
	3. 线程占用的资源比进程少
	4. 能充分利用多处理器的可并行数量
	5. 在等待慢速I/O操作结束的同时，程序可执行其他的计算机任务
	6. 计算密集型应用，为了能够在多处理器系统上运行，将计算分解到多个线程中实现
	7. I/O密集型应用，为了提高性能，将I/O操作重叠。线程能够同时等待不同I/O操作

# 线程的缺点  

	1. 性能缺失
		一个很少被外部事件阻塞的计算机密集型线程往往无法与其他线程共享一个处理器。
		这里的性能缺失指的是增加了额外的同步和调度开销，而可用的资源不变
	2. 健壮性降低
		线程之间是缺乏保护的。在一个多线程程序里面，因时间分配上的细微偏差或者
		因共享了不该共享的的变量而造成不良影响的可能性是很大的
	3. 缺乏访问控制
		进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响
	4. 编程难度高
		编写与调试一个多线程程序比但单线程程序困难的多

# 线程异常  

	1. 单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随之崩溃
	2. 线程是进程的执行分支，线程出现异常，就类似进程出异常，进而触发信号机制，终止进程，进程中止，该进程内的所有线程也就随即退出

# 线程用途  

	1. 合理的使用多线程，能提高CPU密集型程序的执行效率
	2. 合理的使用多线程，能提高IO密集型程序的用户体验
	
# 进程 & 线程  

	1. 进程是资源分配的基本单位
	2. 线程是调度的基本单位
	3. 线程共享进程数据，但也有自己的数据：
		a. 线程ID
		b. 一组寄存器(上下文)	-- 重要
		c. 栈					-- 重要
		d. errno
		e. 信号屏蔽字
		f. 调度优先级

# 进程的多个线程共享  

	- 同一地址空间，定义的函数，全局变量都能够访问，除此之外：
		1. 文件描述符表
		2. 每种信号的处理方式(SIG_IGN、SIG_DFL或者自定义的信号处理函数)
		3. 当前工作目录
		4. 用户ID和组ID

# POSIX -- NPTL原生线程库  

- pthread	-- 需要指定链接-pthread
    - int pthread_create(pthread_t\* thread, const pthread_attr_t\* attr, void \*(\*statr_routine)(void\*), void\* arg);
        - typedef pthread_t unsigned long int
    - pthread_t pthread_self(void);
        - 所谓的线程ID，就是线程在线程库线程控制块的起始位置
- 线程等待
	- pthread_join(pthread_t thread, void\*\* retval);

- 线程退出
	- pthread_exit(void\* retval);

- 线程取消
	- pthread_cancel(pthread_t thread);
		- 返回值的类型是一个宏：PTHREAD_CANCELED
		``` C
		#define PTHREAD_CANCELED (void\*)-1
		```
- 分离线程
	- 默认情况下，新创建的线程是joinable的，线程退出后，需要对其pthread_jion操作，否则无法释放资源，从而造成系统泄漏
	- 如果不关心线程的返回值，join是一种负担，因此，我们可以告诉系统，当线程退出后，自动释放线程资源
		- int pthread_detach(pthread_t thread);
		> 可以是线程组内其他线程对目标线程进行分离，也可以是线程自己分离：
		- pthread_detach(pthread_self());

# Linux线程互斥
- 临界资源
> 被多个执行流访问的资源被叫做临界资源
- 临界区
> 访问临界资源的代码被叫做临界区
- 互斥锁
	- pthread_mutex_init(pthread_mutex_t\* restrict mutex, const pthread_mutexattr_t\* restrict attr);
	- pthread_mutex_destory(pthread_mutex_t\* mutex);
	- pthread_mutex_lock(pthread_mutex_t\* mutex);
	- pthread_mutex_unlock(pthread_mutex_t\* mutex);

> 1. 对临界区进行保护，所有的执行线程都必须遵循这个规则(编码)
> 2. 先加锁(lock)，再访问临界区，最后再解锁(unlock)
> 3. 所有的线程必须先看到同一把锁， **锁本身就是一种临界资源**， 所以锁本身得保证自身安全
>> 申请锁的过程不能有中间状态(也就是两态的)，也就是必须保持加锁的操作是原子性的
> 4. 在访问临界区的时候是需要时间的，在特定线程/进程拥有锁的时候，期间有新进程申请锁，一定申请不到的。新线程应该阻塞，将进程/线程对应的PCB投入到等待队列，，unlock之后，进行进程/线程的唤醒操作
> 5. 理解POSIX pthread中的mutex
```C
struct mutex{
	int lock; //0/1
	wait_queue* head;
}
```

> 6. 一次保证只有一个线程进入临界区，访问临界资源，就叫做互斥
> 7. 加锁会影响效率
- 互斥锁的实质
``` C
lock:
	mov $0, %al
	xchg %al, mutex
	if al寄存器的内容 > 0
		return 0
	else
		等待挂起
	goto lock
unlock:
	mov $1, mutex
	唤醒等待Mutex的线程
	return 0
```

- 线程安全
> 多个线程并发同一段代码，不会出现不同的结果。常见对全局变量或者静态变量进行操作，并且没有锁的保护，会出现线程不安全

- 可重入
> 同一个函数被不同的执行流调用，当前一个流程还没有执行完，就有其他的执行流再次进入，我们称之为重入

- 常见的线程不安全
	1. 不保护共享变量的函数
	2. 函数状态
	3. 返回指向静态变量指针的函数
	4. 调用线程不安全函数的函数

- 常见的线程安全
	1. 每个线程对全局变量或静态变量只有读取的权限，没有写入的权限，一般来说是安全的
	2. 类或接口对于线程来说都是原子操作
	3. 多个线程之间的切换不会导致该接口的执行程序产生二义性

- 常见的不可重入
	1. 调用malloc/free函数，因为malloc函数使用全局链表来管理堆的
	2. 调用标准I/O库函数，标准I/O库的很多实现都以不可重入的方式使用全局数据结构
	3. 可重入函数体内使用了静态的数据结构

- 常见的可重入
	1. 不使用全局变量或静态变量
	2. 不使用用malloc或者new开辟的空间
	3. 不调用不可重入的函数
	4. 不返回静态或全局数据，所有数据都有函数的调用者提供
	5. 使用本地数据，或者通过制作全局数据的本地拷贝来保护全局变量

- 可重入和线程安全的联系
	1. 函数是可重入的，那么线程就是安全的
	2. 函数是不可重入的，那就不能由多个线程使用，有可能引发线程安全问题
	3. 如果一个函数中有全局变量，那么这个函数既不是线程安全也不是可重入的

- 可重入和线程安全的区别
	1. 可重入函数是线程安全函数的一种
	2. 线程安全不一定是可重入的，可重入的函数一定是线程安全的
	3. 如果将对临界资源的访问加上锁，则这个函数是线程安全的，但如果这个重入函数若锁还未释放则会产生死锁

# 死锁
> 死锁是指在一组进程中各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于一种永久的等待状态

- 死锁四个必要条件
	1. 互斥：一个资源每次只能被一个执行流使用
	2. 请求与保持：一个执行流因请求资源而阻塞时，对已获得的资源保持不放
	3. 不剥夺：一个执行流已获得的资源，在未使用完毕之前，不能强行剥夺
	4. 循环等待：若干执行流之间形成一种头尾相接的循环等待资源的关系

- 避免死锁
	1. 破坏死锁的四个必要条件
	2. 加锁循序一致
	3. 避免锁未释放的场景
	4. 资源一次性分配

- 避免死锁算法
	1. 死锁检测算法
	2. 银行家算法

# Linux线程同步
> **完成临界区与临界资源访问时具有一定的顺序性**
> **在保证数据安全的情况下(一般使用加锁来保证)，让多个执行流按照特定的顺序进行临界资源的访问**

- 为什么要存在同步？
> **多线程协同高效完成某些事情**

- 如何编码实现
	1. 条件如果不满足，等待，释放锁
	2. 通知机制

- 条件变量
```C
	int pthread_cond_init(pthread_cond_t* restrict cond, const pthread_condattr_t* restrict attr);
	int pthread_cond_destroy(pthread_cond_t* cond);
	pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
```

- 条件等待
```C
	int pthread_cond_wait(pthread_cond_t* restrict cond, pthread_mutex_t* restrict mutex);
	int pthread_cond_timewait(pthread_cond_t* restrict cond, pthread_mutex_t* restrict mutex, const struct timesoec* restrict abstime);
```
> **为什么wait需要带一把锁？**
> **等待需要判断条件是否满足，如果要判断需要进入临界区，因此必须带入一把锁，且wait时必须要释放锁**
> **在调用该函数的时候，自动会释放锁**
> **当该函数被返回时，返回到临界区内，所以该函数会让该线程重新持有该锁**


- 条件信号
```C
	int pthread_cond_signal(pthread_cond_t* cond);
```

- cond
```C
struct{
	int value;
	wait_queue* head;
}
```

# 生产者消费者模型
> 通过一个容器来解决生产者和消费者之间的强耦合问题。生产者和消费者之间彼此不直接通讯，而是通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里面取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者解耦的
>> **在这里：**
>> **生产者，消费者：进程、线程**
>> **空间、交易场所：一块“内存快”**
>> **产品：数据**
>> "321关系"
>> 3:三种关系，生vs生(互斥)， 生vs消(同步)， 消vs消(互斥)
>> 2:两种角色，生产者和消费者
>> 1:一个交易


- 模型优点
	1. 解耦
	2. 支持并发
	3. 

# POSIX信号量

> 信号量(信号灯)本质是一个计数器！描述临界资源有效个数的计数器

- 为什么？
> 因为临界资源可以看成多份不冲突的，提高效率

- 怎么用？
	- 初始化
```C
	int sem_init(sem_t* sem, int pshared, unsigned int value);
	//pshared：0表示线程间共享，非零表示进程间共享
	//value：信号量初始值
```
	- 销毁
```C
	int sem_destroy(sem_t* sem);
```
	- 等待
```C
	int sem_wait(sem_t* sem);//P操作，使信号量--
```
	- 发布
```C
	int sem_post(sem_t* sem)//V操作，归还资源，使信号量++
```

> **二元信号量相当于互斥锁**

# 基于环形队列的生产消费模型
